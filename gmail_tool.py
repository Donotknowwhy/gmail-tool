"""
Gmail Tool - Tool ch√≠nh ƒë·ªÉ truy c·∫≠p v√† ph√¢n t√≠ch email Gmail
"""
import os
import sys
from datetime import datetime
from typing import List, Dict, Optional
from tabulate import tabulate
from colorama import init, Fore, Style

from gmail_auth import GmailAuthenticator
from email_fetcher import EmailFetcher
from email_filter import EmailFilter
from content_analyzer import ContentAnalyzer
from config import DEFAULT_MAX_RESULTS

# Kh·ªüi t·∫°o colorama
init(autoreset=True)


class GmailTool:
    def __init__(self):
        self.authenticator = GmailAuthenticator()
        self.fetcher = None
        self.filter = EmailFilter()
        self.analyzer = ContentAnalyzer()
        self.service = None
    
    def initialize(self) -> bool:
        """
        Kh·ªüi t·∫°o tool v√† x√°c th·ª±c v·ªõi Gmail
        
        Returns:
            True n·∫øu kh·ªüi t·∫°o th√†nh c√¥ng, False n·∫øu c√≥ l·ªói
        """
        print(f"{Fore.CYAN}üöÄ ƒêang kh·ªüi t·∫°o Gmail Tool...")
        
        # Ki·ªÉm tra xem c√≥ c·∫ßn ƒëƒÉng nh·∫≠p l·∫°i kh√¥ng
        token_file = "token.json"
        if not os.path.exists(token_file):
            print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y token. S·∫Ω y√™u c·∫ßu ƒëƒÉng nh·∫≠p l·∫°i...")
        
        # X√°c th·ª±c v·ªõi Gmail
        if not self.authenticator.authenticate():
            print(f"{Fore.RED}‚ùå Kh√¥ng th·ªÉ x√°c th·ª±c v·ªõi Gmail API")
            return False
        
        self.service = self.authenticator.get_service()
        self.fetcher = EmailFetcher(self.service)
        
        print(f"{Fore.GREEN}‚úÖ Kh·ªüi t·∫°o th√†nh c√¥ng!")
        return True
    
    def fetch_emails(self, query: str = '', max_results: int = DEFAULT_MAX_RESULTS) -> List[Dict]:
        """
        L·∫•y danh s√°ch email t·ª´ Gmail
        
        Args:
            query: Query string ƒë·ªÉ l·ªçc email
            max_results: S·ªë l∆∞·ª£ng email t·ªëi ƒëa
            
        Returns:
            Danh s√°ch email
        """
        if not self.fetcher:
            print(f"{Fore.RED}‚ùå Tool ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o")
            return []
        
        print(f"{Fore.YELLOW}üìß ƒêang l·∫•y email t·ª´ Gmail...")
        emails = self.fetcher.get_emails(query, max_results)
        
        if emails:
            print(f"{Fore.GREEN}‚úÖ ƒê√£ l·∫•y ƒë∆∞·ª£c {len(emails)} email")
        else:
            print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y email n√†o")
        
        return emails
    
    def filter_emails(self, emails: List[Dict], **filters) -> List[Dict]:
        """
        L·ªçc email theo c√°c ti√™u ch√≠
        
        Args:
            emails: Danh s√°ch email c·∫ßn l·ªçc
            **filters: C√°c ti√™u ch√≠ l·ªçc
            
        Returns:
            Danh s√°ch email ƒë√£ ƒë∆∞·ª£c l·ªçc
        """
        if not emails:
            return []
        
        print(f"{Fore.YELLOW}üîç ƒêang l·ªçc {len(emails)} email...")
        filtered_emails = self.filter.filter_emails(emails, **filters)
        
        print(f"{Fore.GREEN}‚úÖ ƒê√£ l·ªçc ƒë∆∞·ª£c {len(filtered_emails)} email ph√π h·ª£p")
        return filtered_emails
    
    def analyze_emails(self, emails: List[Dict]) -> List[Dict]:
        """
        Ph√¢n t√≠ch n·ªôi dung email v√† ƒë√°nh d·∫•u tr·∫°ng th√°i
        
        Args:
            emails: Danh s√°ch email c·∫ßn ph√¢n t√≠ch
            
        Returns:
            Danh s√°ch email ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch
        """
        if not emails:
            return []
        
        print(f"{Fore.YELLOW}üî¨ ƒêang ph√¢n t√≠ch {len(emails)} email...")
        analyzed_emails = self.analyzer.analyze_emails(emails)
        
        # Hi·ªÉn th·ªã t√≥m t·∫Øt
        summary = self.analyzer.get_status_summary(analyzed_emails)
        self._display_status_summary(summary)
        
        return analyzed_emails
    
    def display_emails(self, emails: List[Dict], show_body: bool = False, limit: int = 20):
        """
        Hi·ªÉn th·ªã danh s√°ch email
        
        Args:
            emails: Danh s√°ch email c·∫ßn hi·ªÉn th·ªã
            show_body: C√≥ hi·ªÉn th·ªã n·ªôi dung email kh√¥ng
            limit: S·ªë l∆∞·ª£ng email t·ªëi ƒëa hi·ªÉn th·ªã
        """
        if not emails:
            print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng c√≥ email n√†o ƒë·ªÉ hi·ªÉn th·ªã")
            return
        
        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng hi·ªÉn th·ªã
        display_emails = emails[:limit]
        
        print(f"\n{Fore.CYAN}{'='*80}")
        print(f"{Fore.CYAN}üìã DANH S√ÅCH EMAIL ({len(display_emails)}/{len(emails)})")
        print(f"{Fore.CYAN}{'='*80}")
        
        for i, email in enumerate(display_emails, 1):
            self._display_single_email(email, i, show_body)
        
        if len(emails) > limit:
            print(f"\n{Fore.YELLOW}... v√† {len(emails) - limit} email kh√°c")
    
    def _display_single_email(self, email: Dict, index: int, show_body: bool = False):
        """Hi·ªÉn th·ªã m·ªôt email"""
        # M√†u s·∫Øc theo tr·∫°ng th√°i
        status = email.get('status', 'UNKNOWN')
        if status == 'COMPLETE':
            status_color = Fore.GREEN
        elif status == 'ERROR':
            status_color = Fore.RED
        elif status == 'PACKAGE_SUCCESS':
            status_color = Fore.GREEN
        elif status == 'PACKAGE_FAILED':
            status_color = Fore.RED
        else:
            status_color = Fore.YELLOW
        
        print(f"\n{Fore.WHITE}{index}. {email.get('subject', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')}")
        print(f"   {Fore.BLUE}T·ª´: {email.get('from', 'Kh√¥ng x√°c ƒë·ªãnh')}")
        print(f"   {Fore.BLUE}Ng√†y: {email.get('date', 'Kh√¥ng x√°c ƒë·ªãnh')}")
        print(f"   {Fore.BLUE}Tr·∫°ng th√°i: {status_color}{status}")
        
        # Hi·ªÉn th·ªã order number n·∫øu c√≥
        order_number = email.get('order_number', '')
        if order_number:
            print(f"   {Fore.CYAN}üì¶ Order Number: {order_number}")
        
        if email.get('matched_keywords'):
            keywords = email['matched_keywords']
            if keywords.get('complete'):
                print(f"   {Fore.GREEN}‚úÖ T·ª´ kh√≥a COMPLETE: {', '.join(keywords['complete'])}")
            if keywords.get('error'):
                print(f"   {Fore.RED}‚ùå T·ª´ kh√≥a ERROR: {', '.join(keywords['error'])}")
        
        if show_body and email.get('body'):
            body_preview = email['body'][:200] + "..." if len(email['body']) > 200 else email['body']
            print(f"   {Fore.WHITE}N·ªôi dung: {body_preview}")
    
    def _display_status_summary(self, summary: Dict[str, int]):
        """Hi·ªÉn th·ªã t√≥m t·∫Øt tr·∫°ng th√°i"""
        print(f"\n{Fore.CYAN}{'='*50}")
        print(f"{Fore.CYAN}üìä T√ìM T·∫ÆT TR·∫†NG TH√ÅI")
        print(f"{Fore.CYAN}{'='*50}")
        
        # T√≠nh t·ªïng COMPLETE (bao g·ªìm c·∫£ PACKAGE_SUCCESS)
        complete_total = summary.get('COMPLETE', 0) + summary.get('PACKAGE_SUCCESS', 0)
        # T√≠nh t·ªïng ERROR (bao g·ªìm c·∫£ PACKAGE_FAILED)
        error_total = summary.get('ERROR', 0) + summary.get('PACKAGE_FAILED', 0)
        
        print(f"{Fore.GREEN}‚úÖ COMPLETE: {complete_total}")
        print(f"{Fore.RED}‚ùå ERROR: {error_total}")
        print(f"{Fore.WHITE}üìß T·ªîNG C·ªòNG: {summary['TOTAL']}")
    
    def _display_order_numbers(self, emails: List[Dict]):
        """Hi·ªÉn th·ªã danh s√°ch order number theo tr·∫°ng th√°i"""
        complete_orders = []
        error_orders = []
        
        for email in emails:
            order_number = email.get('order_number', '')
            status = email.get('status', '')
            
            if order_number:  # Ch·ªâ hi·ªÉn th·ªã n·∫øu c√≥ order number
                if status in ['COMPLETE', 'PACKAGE_SUCCESS']:
                    complete_orders.append(order_number)
                elif status in ['ERROR', 'PACKAGE_FAILED']:
                    error_orders.append(order_number)
        
        if complete_orders:
            print(f"\n{Fore.GREEN}üì¶ DANH S√ÅCH ORDER NUMBER - COMPLETE:")
            for i, order in enumerate(complete_orders, 1):
                print(f"   {i}. {order}")
        
        if error_orders:
            print(f"\n{Fore.RED}üì¶ DANH S√ÅCH ORDER NUMBER - ERROR:")
            for i, order in enumerate(error_orders, 1):
                print(f"   {i}. {order}")
        
        if not complete_orders and not error_orders:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y order number n√†o")
    
    def export_results(self, emails: List[Dict], filename: str = None):
        """
        Xu·∫•t k·∫øt qu·∫£ ra file
        
        Args:
            emails: Danh s√°ch email c·∫ßn xu·∫•t
            filename: T√™n file (n·∫øu kh√¥ng c√≥ s·∫Ω t·ª± ƒë·ªông t·∫°o)
        """
        if not emails:
            print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t")
            return
        
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"gmail_results_{timestamp}.txt"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("GMAIL TOOL - K·∫æT QU·∫¢ PH√ÇN T√çCH EMAIL\n")
                f.write("="*50 + "\n\n")
                
                for i, email in enumerate(emails, 1):
                    f.write(f"{i}. {email.get('subject', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')}\n")
                    f.write(f"   T·ª´: {email.get('from', 'Kh√¥ng x√°c ƒë·ªãnh')}\n")
                    f.write(f"   Ng√†y: {email.get('date', 'Kh√¥ng x√°c ƒë·ªãnh')}\n")
                    f.write(f"   Tr·∫°ng th√°i: {email.get('status', 'UNKNOWN')}\n")
                    
                    # Hi·ªÉn th·ªã order number n·∫øu c√≥
                    order_number = email.get('order_number', '')
                    if order_number:
                        f.write(f"   Order Number: {order_number}\n")
                    
                    if email.get('matched_keywords'):
                        keywords = email['matched_keywords']
                        if keywords.get('complete'):
                            f.write(f"   T·ª´ kh√≥a COMPLETE: {', '.join(keywords['complete'])}\n")
                        if keywords.get('error'):
                            f.write(f"   T·ª´ kh√≥a ERROR: {', '.join(keywords['error'])}\n")
                    
                    f.write("\n")
            
            print(f"{Fore.GREEN}‚úÖ ƒê√£ xu·∫•t k·∫øt qu·∫£ ra file: {filename}")
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå L·ªói khi xu·∫•t file: {str(e)}")
    
    def _export_order_search_results(self):
        """Xu·∫•t k·∫øt qu·∫£ t√¨m ki·∫øm order number ra file"""
        try:
            from datetime import datetime
            
            # T·∫°o t√™n file v·ªõi timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"order_search_results_{timestamp}.txt"
            
            results = self.last_search_results
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("K·∫æT QU·∫¢ T√åM KI·∫æM ORDER NUMBERS\n")
                f.write("="*50 + "\n\n")
                f.write(f"Ph·∫°m vi t√¨m ki·∫øm: T·∫•t c·∫£ email (m·ªçi l√∫c)\n")
                f.write(f"T·ªïng s·ªë order t√¨m ki·∫øm: {len(results['success_orders']) + len(results['failed_orders'])}\n\n")
                
                f.write("ORDER SUCCESS:\n")
                f.write("-" * 20 + "\n")
                if results['success_orders']:
                    total_success_qty = 0
                    for order_data in results['success_orders']:
                        order = order_data['order']
                        quantity = order_data['quantity']
                        if quantity:
                            f.write(f"‚úÖ {order} - qty: {quantity}\n")
                            try:
                                total_success_qty += int(quantity)
                            except ValueError:
                                pass
                        else:
                            f.write(f"‚úÖ {order}\n")
                    if total_success_qty > 0:
                        f.write(f"\nüìä T·ªïng quantity SUCCESS: {total_success_qty}\n")
                else:
                    f.write("Kh√¥ng c√≥ order n√†o th√†nh c√¥ng\n")
                
                f.write("\nORDER FAILED:\n")
                f.write("-" * 20 + "\n")
                if results['failed_orders']:
                    total_failed_qty = 0
                    for order_data in results['failed_orders']:
                        order = order_data['order']
                        quantity = order_data['quantity']
                        if quantity:
                            f.write(f"‚ùå {order} - quantity: {quantity}\n")
                            try:
                                total_failed_qty += int(quantity)
                            except ValueError:
                                pass
                        else:
                            f.write(f"‚ùå {order}\n")
                    if total_failed_qty > 0:
                        f.write(f"\nüìä T·ªïng quantity FAILED: {total_failed_qty}\n")
                else:
                    f.write("Kh√¥ng c√≥ order n√†o th·∫•t b·∫°i\n")
                
                f.write("\nORDER NOT FOUND:\n")
                f.write("-" * 20 + "\n")
                if results.get('not_found_orders'):
                    for order in results['not_found_orders']:
                        f.write(f"üîç {order}\n")
                else:
                    f.write("Kh√¥ng c√≥ order n√†o kh√¥ng t√¨m th·∫•y\n")
                
                f.write(f"\nT·ªïng k·∫øt:\n")
                f.write(f"- Th√†nh c√¥ng: {len(results['success_orders'])} orders\n")
                f.write(f"- Th·∫•t b·∫°i: {len(results['failed_orders'])} orders\n")
                f.write(f"- Kh√¥ng t√¨m th·∫•y: {len(results.get('not_found_orders', []))} orders\n")
            
            print(f"{Fore.GREEN}‚úÖ ƒê√£ xu·∫•t k·∫øt qu·∫£ t√¨m ki·∫øm order ra file: {filename}")
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå L·ªói khi xu·∫•t file: {str(e)}")
    
    def run_interactive_mode(self):
        """Ch·∫°y ch·∫ø ƒë·ªô t∆∞∆°ng t√°c"""
        print(f"{Fore.CYAN}{'='*60}")
        print(f"{Fore.CYAN}üéØ GMAIL TOOL - CH·∫æ ƒê·ªò T∆Ø∆†NG T√ÅC")
        print(f"{Fore.CYAN}{'='*60}")
        
        while True:
            print(f"\n{Fore.WHITE}Ch·ªçn ch·ª©c nƒÉng:")
            print(f"{Fore.GREEN}1. T√¨m ki·∫øm ƒë∆°n h√†ng theo order number")
            print(f"{Fore.GREEN}2. Xu·∫•t k·∫øt qu·∫£ ra file")
            print(f"{Fore.CYAN}3. Xem 10 email m·ªõi nh·∫•t")
            print(f"{Fore.YELLOW}4. ƒê·ªïi t√†i kho·∫£n Google (x√≥a token)")
            print(f"{Fore.RED}0. Tho√°t")
            
            choice = input(f"\n{Fore.YELLOW}Nh·∫≠p l·ª±a ch·ªçn (0-4): ").strip()
            
            if choice == '0':
                print(f"{Fore.CYAN}üëã T·∫°m bi·ªát!")
                break
            elif choice == '1':
                self._handle_search_orders_by_number()
            elif choice == '2':
                self._handle_export()
            elif choice == '3':
                self._handle_view_latest_emails()
            elif choice == '4':
                self._handle_change_account()
            else:
                print(f"{Fore.RED}‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá")
    
    def _handle_search_orders_by_number(self):
        """X·ª≠ l√Ω t√¨m ki·∫øm ƒë∆°n h√†ng theo order number t·ª´ file"""
        # Ki·ªÉm tra v√† kh·ªüi t·∫°o l·∫°i n·∫øu c·∫ßn
        if not self.service or not self.fetcher:
            if not self.initialize():
                return
        
        # M·∫∑c ƒë·ªãnh t√¨m ki·∫øm t·∫•t c·∫£ email (m·ªçi l√∫c)
        date_from = "m·ªçi l√∫c"
        date_to = "m·ªçi l√∫c"
        date_range_text = "t·∫•t c·∫£ email (m·ªçi l√∫c)"
        query_template = "{order_number}"
        
        # ƒê·ªçc order numbers t·ª´ file
        try:
            with open('order_numbers.txt', 'r', encoding='utf-8') as f:
                order_numbers = [line.strip() for line in f.readlines() if line.strip()]
        except FileNotFoundError:
            print(f"{Fore.RED}‚ùå Kh√¥ng t√¨m th·∫•y file order_numbers.txt")
            return
        
        print(f"\n{Fore.CYAN}üîç ƒêang t√¨m ki·∫øm {len(order_numbers)} order numbers trong t·∫•t c·∫£ email...")
        
        # T√¨m ki·∫øm v√† ph√¢n t√≠ch t·ª´ng order number
        success_orders = []  # List of dicts: {'order': 'xxx', 'quantity': 'yy'}
        failed_orders = []   # List of dicts: {'order': 'xxx', 'quantity': 'yy'}
        not_found_orders = []
        
        for i, order_number in enumerate(order_numbers, 1):
            print(f"\n{Fore.YELLOW}[{i}/{len(order_numbers)}] ƒêang t√¨m ki·∫øm order: {order_number}")
            
            # T√¨m ki·∫øm email ch·ª©a order number
            query = query_template.format(order_number=order_number)
            emails = self.fetcher.get_emails(query=query, max_results=10)
            
            if not emails:
                print(f"   {Fore.RED}‚ùå Kh√¥ng t√¨m th·∫•y email cho order {order_number}")
                not_found_orders.append(order_number)
                continue
            
            # Ph√¢n t√≠ch email
            analyzer = ContentAnalyzer()
            analyzed_emails = analyzer.analyze_emails(emails)
            
            # Ki·ªÉm tra k·∫øt qu·∫£ ph√¢n t√≠ch
            found_success = False
            found_failed = False
            order_quantity = ""
            
            for email in analyzed_emails:
                status = email.get('status', '')
                quantity = email.get('quantity', '')
                
                if status == 'PACKAGE_SUCCESS':
                    found_success = True
                    order_quantity = quantity
                    print(f"   {Fore.GREEN}‚úÖ T√¨m th·∫•y SUCCESS cho order {order_number}")
                    if quantity:
                        print(f"   {Fore.CYAN}üì¶ Quantity: {quantity}")
                    break
                elif status == 'PACKAGE_FAILED':
                    found_failed = True
                    order_quantity = quantity
                    print(f"   {Fore.RED}‚ùå T√¨m th·∫•y FAILED cho order {order_number}")
                    if quantity:
                        print(f"   {Fore.CYAN}üì¶ Quantity: {quantity}")
                    break
            
            if found_success:
                success_orders.append({'order': order_number, 'quantity': order_quantity})
            elif found_failed:
                failed_orders.append({'order': order_number, 'quantity': order_quantity})
            else:
                print(f"   {Fore.YELLOW}‚ö†Ô∏è Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c tr·∫°ng th√°i cho order {order_number}")
                not_found_orders.append(order_number)
        
        # Hi·ªÉn th·ªã k·∫øt qu·∫£ t·ªïng h·ª£p
        print(f"\n{Fore.CYAN}{'='*60}")
        print(f"{Fore.CYAN}üìä K·∫æT QU·∫¢ T√åM KI·∫æM ORDER NUMBERS")
        print(f"{Fore.CYAN}{'='*60}")
        
        print(f"\n{Fore.GREEN}‚úÖ ORDER SUCCESS ({len(success_orders)}):")
        if success_orders:
            total_success_qty = 0
            for order_data in success_orders:
                order = order_data['order']
                quantity = order_data['quantity']
                if quantity:
                    print(f"   {Fore.GREEN}‚Ä¢ {order} - qty: {quantity}")
                    try:
                        total_success_qty += int(quantity)
                    except ValueError:
                        pass
                else:
                    print(f"   {Fore.GREEN}‚Ä¢ {order}")
            if total_success_qty > 0:
                print(f"   {Fore.CYAN}üìä T·ªïng quantity SUCCESS: {total_success_qty}")
        else:
            print(f"   {Fore.YELLOW}Kh√¥ng c√≥ order n√†o th√†nh c√¥ng")
        
        print(f"\n{Fore.RED}‚ùå ORDER FAILED ({len(failed_orders)}):")
        if failed_orders:
            total_failed_qty = 0
            for order_data in failed_orders:
                order = order_data['order']
                quantity = order_data['quantity']
                if quantity:
                    print(f"   {Fore.RED}‚Ä¢ {order} - quantity: {quantity}")
                    try:
                        total_failed_qty += int(quantity)
                    except ValueError:
                        pass
                else:
                    print(f"   {Fore.RED}‚Ä¢ {order}")
            if total_failed_qty > 0:
                print(f"   {Fore.CYAN}üìä T·ªïng quantity FAILED: {total_failed_qty}")
        else:
            print(f"   {Fore.YELLOW}Kh√¥ng c√≥ order n√†o th·∫•t b·∫°i")
        
        print(f"\n{Fore.YELLOW}üîç ORDER NOT FOUND ({len(not_found_orders)}):")
        if not_found_orders:
            for order in not_found_orders:
                print(f"   {Fore.YELLOW}‚Ä¢ {order}")
        else:
            print(f"   {Fore.YELLOW}Kh√¥ng c√≥ order n√†o kh√¥ng t√¨m th·∫•y")
        
        print(f"\n{Fore.CYAN}üìà T·ªïng c·ªông: {len(success_orders)} th√†nh c√¥ng, {len(failed_orders)} th·∫•t b·∫°i, {len(not_found_orders)} kh√¥ng t√¨m th·∫•y")
        
        # L∆∞u k·∫øt qu·∫£ v√†o instance ƒë·ªÉ c√≥ th·ªÉ export
        self.last_search_results = {
            'success_orders': success_orders,
            'failed_orders': failed_orders,
            'not_found_orders': not_found_orders,
            'date_from': date_from,
            'date_to': date_to
        }

    def _handle_analyze_orders_by_date(self):
        """X·ª≠ l√Ω ph√¢n t√≠ch ƒë∆°n h√†ng theo kho·∫£ng th·ªùi gian"""
        # Ki·ªÉm tra v√† kh·ªüi t·∫°o l·∫°i n·∫øu c·∫ßn
        if not self.service or not self.fetcher:
            if not self.initialize():
                return
        
        try:
            print(f"\n{Fore.CYAN}üìÖ PH√ÇN T√çCH ƒê∆†N H√ÄNG THEO KHO·∫¢NG TH·ªúI GIAN")
            print(f"{Fore.CYAN}{'='*50}")
            
            # Nh·∫≠p ng√†y b·∫Øt ƒë·∫ßu (m·∫∑c ƒë·ªãnh l√† 1 th√°ng tr∆∞·ªõc)
            from datetime import datetime, timedelta
            default_date_from = (datetime.now() - timedelta(days=30)).strftime('%d/%m/%Y')
            date_from_input = input(f"{Fore.YELLOW}Nh·∫≠p ng√†y b·∫Øt ƒë·∫ßu (DD/MM/YYYY) [m·∫∑c ƒë·ªãnh: {default_date_from}]: ").strip()
            if not date_from_input:
                date_from_input = default_date_from
            
            # Chuy·ªÉn ƒë·ªïi t·ª´ DD/MM/YYYY sang YYYY-MM-DD
            try:
                date_from = datetime.strptime(date_from_input, '%d/%m/%Y').strftime('%Y-%m-%d')
            except ValueError:
                print(f"{Fore.RED}‚ùå ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng DD/MM/YYYY")
                return
            
            # Nh·∫≠p ng√†y k·∫øt th√∫c (m·∫∑c ƒë·ªãnh l√† ng√†y mai ƒë·ªÉ bao g·ªìm h·∫øt th∆∞ h√¥m nay)
            default_date_to = (datetime.now() + timedelta(days=1)).strftime('%d/%m/%Y')
            date_to_input = input(f"{Fore.YELLOW}Nh·∫≠p ng√†y k·∫øt th√∫c (DD/MM/YYYY) [m·∫∑c ƒë·ªãnh: {default_date_to}]: ").strip()
            if not date_to_input:
                date_to_input = default_date_to
            
            # Chuy·ªÉn ƒë·ªïi t·ª´ DD/MM/YYYY sang YYYY-MM-DD
            try:
                date_to = datetime.strptime(date_to_input, '%d/%m/%Y').strftime('%Y-%m-%d')
            except ValueError:
                print(f"{Fore.RED}‚ùå ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng DD/MM/YYYY")
                return
            
            # Nh·∫≠p s·ªë l∆∞·ª£ng email t·ªëi ƒëa
            max_results = int(input(f"{Fore.YELLOW}Nh·∫≠p s·ªë l∆∞·ª£ng email t·ªëi ƒëa (m·∫∑c ƒë·ªãnh 50): ") or "50")
            
            print(f"\n{Fore.YELLOW}üîç ƒêang t√¨m ki·∫øm email t·ª´ {date_from} ƒë·∫øn {date_to}...")
            
            # T·∫°o query ƒë·ªÉ t√¨m t·∫•t c·∫£ email trong h·ªôp th∆∞ ƒë·∫øn theo kho·∫£ng th·ªùi gian
            query = f"after:{date_from} before:{date_to}"
            
            # L·∫•y email
            emails = self.fetch_emails(query=query, max_results=max_results)
            
            if not emails:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y email n√†o trong kho·∫£ng th·ªùi gian n√†y")
                return
            
            # Ph√¢n t√≠ch email
            print(f"\n{Fore.YELLOW}üî¨ ƒêang ph√¢n t√≠ch {len(emails)} email...")
            analyzed_emails = self.analyze_emails(emails)
            
            # L·ªçc ch·ªâ email li√™n quan ƒë·∫øn ƒë∆°n h√†ng
            package_emails = []
            for email in analyzed_emails:
                status = email.get('status', '')
                if status in ['PACKAGE_SUCCESS', 'PACKAGE_FAILED']:
                    package_emails.append(email)
            
            if package_emails:
                print(f"\n{Fore.GREEN}üì¶ T√¨m th·∫•y {len(package_emails)} email li√™n quan ƒë·∫øn ƒë∆°n h√†ng:")
                self.display_emails(package_emails, show_body=True)
                
                # Hi·ªÉn th·ªã t√≥m t·∫Øt tr·∫°ng th√°i
                summary = self.analyzer.get_status_summary(package_emails)
                self._display_status_summary(summary)
                
                # Hi·ªÉn th·ªã danh s√°ch order number
                self._display_order_numbers(package_emails)
            else:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y email n√†o li√™n quan ƒë·∫øn ƒë∆°n h√†ng")
                
        except ValueError:
            print(f"{Fore.RED}‚ùå ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá")
        except Exception as e:
            print(f"{Fore.RED}‚ùå L·ªói: {str(e)}")
    
    def _handle_search(self):
        """X·ª≠ l√Ω t√¨m ki·∫øm email"""
        # Ki·ªÉm tra v√† kh·ªüi t·∫°o l·∫°i n·∫øu c·∫ßn
        if not self.service or not self.fetcher:
            if not self.initialize():
                return
        
        query = input(f"{Fore.YELLOW}Nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm: ").strip()
        if query:
            emails = self.fetch_emails(query=query)
            if emails:
                self.display_emails(emails)
        else:
            print(f"{Fore.RED}‚ùå Vui l√≤ng nh·∫≠p t·ª´ kh√≥a")
    
    def _handle_export(self):
        """X·ª≠ l√Ω xu·∫•t k·∫øt qu·∫£"""
        # Ki·ªÉm tra xem c√≥ k·∫øt qu·∫£ t·ª´ t√¨m ki·∫øm order number kh√¥ng
        if hasattr(self, 'last_search_results') and self.last_search_results:
            self._export_order_search_results()
            return
        
        # Ki·ªÉm tra v√† kh·ªüi t·∫°o l·∫°i n·∫øu c·∫ßn
        if not self.service or not self.fetcher:
            if not self.initialize():
                return
        
        try:
            print(f"\n{Fore.CYAN}üì§ XU·∫§T K·∫æT QU·∫¢ RA FILE")
            print(f"{Fore.CYAN}{'='*30}")
            
            # Nh·∫≠p ng√†y b·∫Øt ƒë·∫ßu (m·∫∑c ƒë·ªãnh l√† 1 th√°ng tr∆∞·ªõc)
            from datetime import datetime, timedelta
            default_date_from = (datetime.now() - timedelta(days=30)).strftime('%d/%m/%Y')
            date_from_input = input(f"{Fore.YELLOW}Nh·∫≠p ng√†y b·∫Øt ƒë·∫ßu (DD/MM/YYYY) [m·∫∑c ƒë·ªãnh: {default_date_from}]: ").strip()
            if not date_from_input:
                date_from_input = default_date_from
            
            # Chuy·ªÉn ƒë·ªïi t·ª´ DD/MM/YYYY sang YYYY-MM-DD
            try:
                date_from = datetime.strptime(date_from_input, '%d/%m/%Y').strftime('%Y-%m-%d')
            except ValueError:
                print(f"{Fore.RED}‚ùå ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng DD/MM/YYYY")
                return
            
            # Nh·∫≠p ng√†y k·∫øt th√∫c (m·∫∑c ƒë·ªãnh l√† ng√†y mai ƒë·ªÉ bao g·ªìm h·∫øt th∆∞ h√¥m nay)
            default_date_to = (datetime.now() + timedelta(days=1)).strftime('%d/%m/%Y')
            date_to_input = input(f"{Fore.YELLOW}Nh·∫≠p ng√†y k·∫øt th√∫c (DD/MM/YYYY) [m·∫∑c ƒë·ªãnh: {default_date_to}]: ").strip()
            if not date_to_input:
                date_to_input = default_date_to
            
            # Chuy·ªÉn ƒë·ªïi t·ª´ DD/MM/YYYY sang YYYY-MM-DD
            try:
                date_to = datetime.strptime(date_to_input, '%d/%m/%Y').strftime('%Y-%m-%d')
            except ValueError:
                print(f"{Fore.RED}‚ùå ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng DD/MM/YYYY")
                return
            
            # Nh·∫≠p s·ªë l∆∞·ª£ng email t·ªëi ƒëa
            max_results = int(input(f"{Fore.YELLOW}Nh·∫≠p s·ªë l∆∞·ª£ng email t·ªëi ƒëa (m·∫∑c ƒë·ªãnh 50): ") or "50")
            
            print(f"\n{Fore.YELLOW}üîç ƒêang t√¨m ki·∫øm email t·ª´ {date_from} ƒë·∫øn {date_to}...")
            
            # T·∫°o query ƒë·ªÉ t√¨m t·∫•t c·∫£ email trong h·ªôp th∆∞ ƒë·∫øn theo kho·∫£ng th·ªùi gian
            query = f"after:{date_from} before:{date_to}"
            
            # L·∫•y email
            emails = self.fetch_emails(query=query, max_results=max_results)
            
            if not emails:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y email n√†o trong kho·∫£ng th·ªùi gian n√†y")
                return
            
            # Ph√¢n t√≠ch email
            print(f"\n{Fore.YELLOW}üî¨ ƒêang ph√¢n t√≠ch {len(emails)} email...")
            analyzed_emails = self.analyze_emails(emails)
            
            # L·ªçc ch·ªâ email li√™n quan ƒë·∫øn ƒë∆°n h√†ng
            package_emails = []
            for email in analyzed_emails:
                status = email.get('status', '')
                if status in ['PACKAGE_SUCCESS', 'PACKAGE_FAILED']:
                    package_emails.append(email)
            
            if package_emails:
                # T·∫°o t√™n file
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"package_orders_{date_from}_to_{date_to}_{timestamp}.txt"
                
                # Xu·∫•t k·∫øt qu·∫£
                self.export_results(package_emails, filename)
                
                # Hi·ªÉn th·ªã t√≥m t·∫Øt tr·∫°ng th√°i
                summary = self.analyzer.get_status_summary(package_emails)
                self._display_status_summary(summary)
                
                # Hi·ªÉn th·ªã danh s√°ch order number
                self._display_order_numbers(package_emails)
            else:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y email n√†o li√™n quan ƒë·∫øn ƒë∆°n h√†ng")
                
        except ValueError:
            print(f"{Fore.RED}‚ùå ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá")
        except Exception as e:
            print(f"{Fore.RED}‚ùå L·ªói: {str(e)}")
    
    def _handle_view_latest_emails(self):
        """X·ª≠ l√Ω xem 10 email m·ªõi nh·∫•t"""
        # Ki·ªÉm tra v√† kh·ªüi t·∫°o l·∫°i n·∫øu c·∫ßn
        if not self.service or not self.fetcher:
            if not self.initialize():
                return
        
        print(f"\n{Fore.CYAN}üìß XEM 10 EMAIL M·ªöI NH·∫§T")
        print(f"{Fore.CYAN}{'='*40}")
        
        try:
            # L·∫•y 10 email m·ªõi nh·∫•t (t·∫•t c·∫£ email)
            print(f"{Fore.YELLOW}üîç ƒêang l·∫•y 10 email m·ªõi nh·∫•t...")
            emails = self.fetcher.get_emails(query='', max_results=10)
            
            if not emails:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y email n√†o")
                return
            
            # Hi·ªÉn th·ªã danh s√°ch email
            print(f"\n{Fore.GREEN}‚úÖ ƒê√£ l·∫•y ƒë∆∞·ª£c {len(emails)} email m·ªõi nh·∫•t:")
            self.display_emails(emails, show_body=False, limit=10)
                
        except Exception as e:
            print(f"{Fore.RED}‚ùå L·ªói khi l·∫•y email: {str(e)}")

    def _handle_change_account(self):
        """X·ª≠ l√Ω ƒë·ªïi t√†i kho·∫£n Google b·∫±ng c√°ch x√≥a token"""
        print(f"\n{Fore.CYAN}üîÑ ƒê·ªîI T√ÄI KHO·∫¢N GOOGLE")
        print(f"{Fore.CYAN}{'='*40}")
        
        # Ki·ªÉm tra xem c√≥ file token.json kh√¥ng
        token_file = "token.json"
        if os.path.exists(token_file):
            print(f"{Fore.YELLOW}üìÅ T√¨m th·∫•y file token hi·ªán t·∫°i: {token_file}")
            
            # X√°c nh·∫≠n t·ª´ ng∆∞·ªùi d√πng
            confirm = input(f"{Fore.YELLOW}B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a token v√† ƒëƒÉng nh·∫≠p l·∫°i? (y/n): ").strip().lower()
            
            if confirm in ['y', 'yes', 'c√≥']:
                try:
                    # X√≥a file token
                    os.remove(token_file)
                    print(f"{Fore.GREEN}‚úÖ ƒê√£ x√≥a file token th√†nh c√¥ng!")
                    
                    # Th√¥ng b√°o h∆∞·ªõng d·∫´n
                    print(f"\n{Fore.CYAN}üìã H∆Ø·ªöNG D·∫™N:")
                    print(f"{Fore.WHITE}1. Tool s·∫Ω t·ª± ƒë·ªông kh·ªüi t·∫°o l·∫°i khi b·∫°n ch·ªçn ch·ª©c nƒÉng kh√°c")
                    print(f"{Fore.WHITE}2. Tr√¨nh duy·ªát s·∫Ω m·ªü ƒë·ªÉ b·∫°n ch·ªçn Google account m·ªõi")
                    print(f"{Fore.WHITE}3. C·∫•p quy·ªÅn truy c·∫≠p email cho tool")
                    print(f"{Fore.WHITE}4. Token m·ªõi s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông")
                    
                    # Reset authenticator ƒë·ªÉ chu·∫©n b·ªã cho l·∫ßn ƒëƒÉng nh·∫≠p m·ªõi
                    self.authenticator = GmailAuthenticator()
                    self.service = None
                    self.fetcher = None
                    
                    print(f"\n{Fore.GREEN}üéâ Ho√†n t·∫•t! Token ƒë√£ ƒë∆∞·ª£c x√≥a.")
                    print(f"{Fore.YELLOW}üí° L·∫ßn ti·∫øp theo b·∫°n s·ª≠ d·ª•ng tool, s·∫Ω ƒë∆∞·ª£c y√™u c·∫ßu ƒëƒÉng nh·∫≠p l·∫°i.")
                    
                except Exception as e:
                    print(f"{Fore.RED}‚ùå L·ªói khi x√≥a token: {str(e)}")
            else:
                print(f"{Fore.YELLOW}‚ö†Ô∏è H·ªßy b·ªè thao t√°c")
        else:
            print(f"{Fore.YELLOW}‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file token.json")
            print(f"{Fore.WHITE}Tool s·∫Ω t·ª± ƒë·ªông y√™u c·∫ßu ƒëƒÉng nh·∫≠p khi c·∫ßn thi·∫øt.")


def main():
    """H√†m main ƒë·ªÉ ch·∫°y tool"""
    tool = GmailTool()
    
    # Kh·ªüi t·∫°o tool
    if not tool.initialize():
        sys.exit(1)
    
    # Ch·∫°y ch·∫ø ƒë·ªô t∆∞∆°ng t√°c
    tool.run_interactive_mode()


if __name__ == "__main__":
    main()
